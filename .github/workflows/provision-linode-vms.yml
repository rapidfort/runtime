name: Provision Linode VMs with GitHub Runners

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'create'
        type: choice
        options:
          - create
          - destroy
          - status

env:
  LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
  GITHUB_PAT: ${{ secrets.GH_PAT }}  # Personal Access Token with repo scope
  REPO_URL: "https://github.com/rapidfort/runtime"
  LINODE_REGION: "us-east"  # Change as needed
  LINODE_TYPE: "g6-standard-2"  # 2 CPU, 4GB RAM - adjust as needed

jobs:
  manage-infrastructure:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Linode CLI
      run: |
        pip install linode-cli
        echo "Linode CLI installed"

    - name: Create VM provisioning script
      if: inputs.action == 'create'
      run: |
        cat > provision_vms.sh << 'EOF'
        #!/bin/bash
        set -e

        # K8s distributions to deploy
        K8S_DISTROS=("k0s" "k3s" "kind" "kubeadm" "microk8s" "minikube" "rke" "openshift")

        # Function to create a VM
        create_vm() {
            local vm_name=$1
            local vm_label="runner-${vm_name}"
            
            echo "Creating VM: $vm_label"
            
            # Create the Linode instance
            linode_id=$(linode-cli linodes create \
                --type $LINODE_TYPE \
                --region $LINODE_REGION \
                --image linode/ubuntu22.04 \
                --label "$vm_label" \
                --root_pass "${{ secrets.VM_ROOT_PASSWORD }}" \
                --booted true \
                --private_ip true \
                --tags "github-runner,k8s-test,$vm_name" \
                --text --no-headers --format 'id')
            
            echo "Created Linode ID: $linode_id"
            
            # Wait for the VM to be running
            echo "Waiting for VM to be ready..."
            while true; do
                status=$(linode-cli linodes view $linode_id --text --no-headers --format 'status')
                if [ "$status" = "running" ]; then
                    break
                fi
                sleep 10
            done
            
            # Get the VM's IP address
            ip_address=$(linode-cli linodes view $linode_id --text --no-headers --format 'ipv4')
            ip_address=$(echo $ip_address | cut -d' ' -f1)
            
            echo "$vm_label:$linode_id:$ip_address" >> vm_inventory.txt
            echo "VM $vm_label is ready at $ip_address"
            
            # Wait for SSH to be available
            echo "Waiting for SSH to be ready..."
            while ! ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 root@$ip_address "echo SSH ready" 2>/dev/null; do
                sleep 5
            done
            
            # Install GitHub Runner
            install_runner $vm_name $ip_address
        }

        # Function to install GitHub Actions runner
        install_runner() {
            local runner_name=$1
            local ip_address=$2
            
            echo "Installing GitHub Actions runner on $runner_name ($ip_address)"
            
            # Create runner installation script
            cat > install_runner_remote.sh << 'SCRIPT'
        #!/bin/bash
        set -e

        # Update system
        apt-get update
        apt-get upgrade -y
        apt-get install -y curl wget jq build-essential libssl-dev libffi-dev python3-dev

        # Install Docker (needed for most K8s distributions)
        curl -fsSL https://get.docker.com | bash
        usermod -aG docker root

        # Create runner user
        useradd -m -s /bin/bash runner
        usermod -aG sudo runner
        usermod -aG docker runner
        echo "runner ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers

        # Download and install GitHub Actions runner
        su - runner << 'EOF'
        cd ~
        mkdir actions-runner && cd actions-runner
        
        # Get latest runner version
        RUNNER_VERSION=$(curl -s https://api.github.com/repos/actions/runner/releases/latest | jq -r .tag_name | sed 's/v//')
        
        # Download runner
        curl -o actions-runner-linux-x64-${RUNNER_VERSION}.tar.gz -L https://github.com/actions/runner/releases/download/v${RUNNER_VERSION}/actions-runner-linux-x64-${RUNNER_VERSION}.tar.gz
        tar xzf ./actions-runner-linux-x64-${RUNNER_VERSION}.tar.gz
        rm actions-runner-linux-x64-${RUNNER_VERSION}.tar.gz
        
        # Configure runner
        export RUNNER_ALLOW_RUNASROOT=1
        ./config.sh --url $REPO_URL --token $RUNNER_TOKEN --name $RUNNER_NAME --labels $RUNNER_LABELS --unattended --replace
        
        # Install as service
        sudo ./svc.sh install runner
        sudo ./svc.sh start
        EOF

        # Check service status
        systemctl status actions.runner.rapidfort-runtime.$RUNNER_NAME.service
        SCRIPT
            
            # Get runner registration token
            RUNNER_TOKEN=$(curl -s -X POST \
                -H "Authorization: token $GITHUB_PAT" \
                -H "Accept: application/vnd.github.v3+json" \
                https://api.github.com/repos/rapidfort/runtime/actions/runners/registration-token | jq -r .token)
            
            # Copy and execute the installation script
            scp -o StrictHostKeyChecking=no install_runner_remote.sh root@$ip_address:/tmp/
            ssh -o StrictHostKeyChecking=no root@$ip_address "RUNNER_NAME='$runner_name' RUNNER_LABELS='self-hosted,Linux,$runner_name,k8s' RUNNER_TOKEN='$RUNNER_TOKEN' REPO_URL='$REPO_URL' bash /tmp/install_runner_remote.sh"
            
            echo "GitHub Actions runner installed on $runner_name"
        }

        # Main execution
        echo "Starting VM provisioning..."
        
        # Clear inventory file
        > vm_inventory.txt
        
        # Create VMs in parallel (with some delay to avoid API rate limits)
        for distro in "${K8S_DISTROS[@]}"; do
            create_vm "$distro" &
            sleep 5  # Small delay between VM creations
        done

        # Wait for all background jobs to complete
        wait

        echo "All VMs provisioned successfully!"
        echo "VM Inventory:"
        cat vm_inventory.txt
        EOF

        chmod +x provision_vms.sh

    - name: Create VM destruction script
      if: inputs.action == 'destroy'
      run: |
        cat > destroy_vms.sh << 'EOF'
        #!/bin/bash
        set -e

        echo "Destroying all runner VMs..."

        # Get all VMs with our tags
        vm_ids=$(linode-cli linodes list --tags "github-runner,k8s-test" --text --no-headers --format 'id')

        if [ -z "$vm_ids" ]; then
            echo "No VMs found to destroy"
            exit 0
        fi

        # Remove runners from GitHub first
        for vm_id in $vm_ids; do
            vm_label=$(linode-cli linodes view $vm_id --text --no-headers --format 'label')
            runner_name=${vm_label#runner-}
            
            echo "Removing runner $runner_name from GitHub..."
            
            # Get runner ID
            runner_id=$(curl -s \
                -H "Authorization: token $GITHUB_PAT" \
                -H "Accept: application/vnd.github.v3+json" \
                https://api.github.com/repos/rapidfort/runtime/actions/runners | \
                jq -r ".runners[] | select(.name==\"$runner_name\") | .id")
            
            if [ ! -z "$runner_id" ]; then
                curl -s -X DELETE \
                    -H "Authorization: token $GITHUB_PAT" \
                    -H "Accept: application/vnd.github.v3+json" \
                    https://api.github.com/repos/rapidfort/runtime/actions/runners/$runner_id
                echo "Removed runner $runner_name from GitHub"
            fi
        done

        # Destroy VMs
        for vm_id in $vm_ids; do
            echo "Destroying VM ID: $vm_id"
            linode-cli linodes delete $vm_id
        done

        echo "All VMs destroyed successfully!"
        EOF

        chmod +x destroy_vms.sh

    - name: Create status check script
      if: inputs.action == 'status'
      run: |
        cat > check_status.sh << 'EOF'
        #!/bin/bash

        echo "=== Linode VMs Status ==="
        echo ""
        
        # Get all VMs with our tags
        linode-cli linodes list --tags "github-runner,k8s-test" --text --format 'label,status,ipv4,id'
        
        echo ""
        echo "=== GitHub Runners Status ==="
        echo ""
        
        # Get runners from GitHub
        curl -s \
            -H "Authorization: token $GITHUB_PAT" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/rapidfort/runtime/actions/runners | \
            jq -r '.runners[] | select(.labels[].name | contains("k8s")) | {name: .name, status: .status, labels: [.labels[].name] | join(",")}'
        EOF

        chmod +x check_status.sh

    - name: Execute action
      run: |
        case "${{ inputs.action }}" in
          create)
            ./provision_vms.sh
            ;;
          destroy)
            ./destroy_vms.sh
            ;;
          status)
            ./check_status.sh
            ;;
        esac

    - name: Save VM inventory
      if: inputs.action == 'create'
      uses: actions/upload-artifact@v3
      with:
        name: vm-inventory
        path: vm_inventory.txt

    - name: Display summary
      if: always()
      run: |
        echo "## Action Summary" >> $GITHUB_STEP_SUMMARY
        echo "Action performed: ${{ inputs.action }}" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ inputs.action }}" == "create" ] && [ -f vm_inventory.txt ]; then
            echo "### Created VMs:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat vm_inventory.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
        fi

  # Optional: Test the runners
  test-runners:
    needs: manage-infrastructure
    if: inputs.action == 'create'
    runs-on: self-hosted
    strategy:
      matrix:
        runner: [k0s, k3s, kind, kubeadm, microk8s, minikube, rke, openshift]
    
    steps:
    - name: Test runner ${{ matrix.runner }}
      run: |
        echo "Testing runner: ${{ matrix.runner }}"
        echo "Hostname: $(hostname)"
        echo "OS: $(uname -a)"
        echo "Docker version: $(docker --version)"
        echo "Runner is working! âœ“"
