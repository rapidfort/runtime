name: Deploy K8s Clusters on Self-Hosted Runners

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["Provision Linode VMs with GitHub Runners"]
    types:
      - completed

jobs:
  # Deploy k3s
  deploy-k3s:
    runs-on: [self-hosted, k3s]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install k3s
      run: |
        echo "Installing k3s on $(hostname)..."
        curl -sfL https://get.k3s.io | sh -s - --write-kubeconfig-mode 644
        
        # Wait for k3s to be ready
        sudo k3s kubectl wait --for=condition=Ready nodes --all --timeout=300s
        
        # Verify installation
        sudo k3s kubectl get nodes
        sudo k3s kubectl get pods --all-namespaces
        
        # Copy kubeconfig for easy access
        mkdir -p $HOME/.kube
        sudo cp /etc/rancher/k3s/k3s.yaml $HOME/.kube/config
        sudo chown $(id -u):$(id -g) $HOME/.kube/config
        
        echo "k3s installation completed!"

  # Deploy kind
  deploy-kind:
    runs-on: [self-hosted, kind]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install kind
      run: |
        echo "Installing kind on $(hostname)..."
        
        # Download kind
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
        chmod +x ./kind
        sudo mv ./kind /usr/local/bin/kind
        
        # Create kind cluster
        kind create cluster --name rfruntime-test --wait 5m
        
        # Verify installation
        kubectl cluster-info --context kind-rfruntime-test
        kubectl get nodes
        
        echo "kind installation completed!"

  # Deploy k0s
  deploy-k0s:
    runs-on: [self-hosted, k0s]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install k0s
      run: |
        echo "Installing k0s on $(hostname)..."
        
        # Download and install k0s
        curl -sSLf https://get.k0s.sh | sudo sh
        
        # Install k0s controller with worker
        sudo k0s install controller --single
        sudo k0s start
        
        # Wait for k0s to be ready
        sleep 30
        sudo k0s status
        
        # Export kubeconfig
        sudo k0s kubeconfig admin > $HOME/.kube/config
        chmod 600 $HOME/.kube/config
        
        # Verify installation
        kubectl get nodes
        kubectl get pods --all-namespaces
        
        echo "k0s installation completed!"

  # Deploy microk8s
  deploy-microk8s:
    runs-on: [self-hosted, microk8s]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install microk8s
      run: |
        echo "Installing microk8s on $(hostname)..."
        
        # Install microk8s
        sudo snap install microk8s --classic
        
        # Add user to microk8s group
        sudo usermod -a -G microk8s $USER
        sudo chown -f -R $USER ~/.kube
        
        # Apply group changes
        newgrp microk8s << EOF
        microk8s status --wait-ready
        microk8s enable dns storage ingress
        EOF
        
        # Export config
        sudo microk8s config > $HOME/.kube/config
        chmod 600 $HOME/.kube/config
        
        # Verify installation
        microk8s kubectl get nodes
        microk8s kubectl get pods --all-namespaces
        
        echo "microk8s installation completed!"

  # Deploy minikube
  deploy-minikube:
    runs-on: [self-hosted, minikube]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install minikube
      run: |
        echo "Installing minikube on $(hostname)..."
        
        # Download minikube
        curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
        sudo install minikube-linux-amd64 /usr/local/bin/minikube
        rm minikube-linux-amd64
        
        # Start minikube with docker driver
        minikube start --driver=docker --cpus=2 --memory=3072
        
        # Enable addons
        minikube addons enable ingress
        minikube addons enable dashboard
        
        # Verify installation
        minikube status
        kubectl get nodes
        kubectl get pods --all-namespaces
        
        echo "minikube installation completed!"

  # Deploy kubeadm
  deploy-kubeadm:
    runs-on: [self-hosted, kubeadm]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install kubeadm
      run: |
        echo "Installing kubeadm on $(hostname)..."
        
        # Disable swap
        sudo swapoff -a
        sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
        
        # Load required modules
        cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf
        overlay
        br_netfilter
        EOF
        
        sudo modprobe overlay
        sudo modprobe br_netfilter
        
        # Set up required sysctl params
        cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
        net.bridge.bridge-nf-call-iptables  = 1
        net.bridge.bridge-nf-call-ip6tables = 1
        net.ipv4.ip_forward                 = 1
        EOF
        
        sudo sysctl --system
        
        # Install containerd
        sudo apt-get update
        sudo apt-get install -y containerd
        sudo mkdir -p /etc/containerd
        containerd config default | sudo tee /etc/containerd/config.toml
        sudo systemctl restart containerd
        
        # Install kubeadm, kubelet, kubectl
        sudo apt-get update
        sudo apt-get install -y apt-transport-https ca-certificates curl
        sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
        echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
        sudo apt-get update
        sudo apt-get install -y kubelet kubeadm kubectl
        sudo apt-mark hold kubelet kubeadm kubectl
        
        # Initialize cluster
        sudo kubeadm init --pod-network-cidr=10.244.0.0/16
        
        # Set up kubeconfig
        mkdir -p $HOME/.kube
        sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
        sudo chown $(id -u):$(id -g) $HOME/.kube/config
        
        # Install Flannel CNI
        kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml
        
        # Remove taint from master node to schedule pods
        kubectl taint nodes --all node-role.kubernetes.io/control-plane- || true
        kubectl taint nodes --all node-role.kubernetes.io/master- || true
        
        # Wait for node to be ready
        kubectl wait --for=condition=Ready nodes --all --timeout=300s
        
        # Verify installation
        kubectl get nodes
        kubectl get pods --all-namespaces
        
        echo "kubeadm installation completed!"

  # Deploy RKE
  deploy-rke:
    runs-on: [self-hosted, rke]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install RKE
      run: |
        echo "Installing RKE on $(hostname)..."
        
        # Download RKE
        curl -s https://api.github.com/repos/rancher/rke/releases/latest | \
          grep browser_download_url | grep amd64 | cut -d '"' -f 4 | wget -qi -
        chmod +x rke_linux-amd64
        sudo mv rke_linux-amd64 /usr/local/bin/rke
        
        # Generate SSH key for local access
        ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N "" -q
        cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys
        chmod 600 ~/.ssh/authorized_keys
        
        # Create RKE cluster config
        cat > cluster.yml <<EOF
        nodes:
          - address: 127.0.0.1
            internal_address: 127.0.0.1
            user: $USER
            role: [controlplane, worker, etcd]
            ssh_key_path: ~/.ssh/id_rsa
        
        services:
          etcd:
            snapshot: true
            creation: 6h
            retention: 24h
        
        ingress:
          provider: nginx
          options:
            use-forwarded-headers: "true"
        EOF
        
        # Deploy RKE cluster
        rke up --config ./cluster.yml
        
        # Set up kubeconfig
        mkdir -p $HOME/.kube
        cp kube_config_cluster.yml $HOME/.kube/config
        
        # Verify installation
        kubectl get nodes
        kubectl get pods --all-namespaces
        
        echo "RKE installation completed!"

  # Deploy OpenShift (using OKD - the community version)
  deploy-openshift:
    runs-on: [self-hosted, openshift]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install OKD/OpenShift
      run: |
        echo "Installing OKD (OpenShift community) on $(hostname)..."
        
        # Note: Full OpenShift requires significant resources
        # Installing CodeReady Containers (CRC) as a lightweight alternative
        
        # Download CRC
        CRC_VERSION="2.30.0"
        wget https://developers.redhat.com/content-gateway/rest/mirror/pub/openshift-v4/clients/crc/${CRC_VERSION}/crc-linux-amd64.tar.xz
        tar xf crc-linux-amd64.tar.xz
        sudo mv crc-linux-*-amd64/crc /usr/local/bin/
        rm -rf crc-linux-*
        
        # Setup CRC
        crc setup
        
        # Configure CRC with minimal resources
        crc config set cpus 2
        crc config set memory 8192
        crc config set disk-size 30
        
        # Start CRC
        crc start
        
        # Get credentials
        eval $(crc oc-env)
        oc login -u developer https://api.crc.testing:6443
        
        # Verify installation
        oc get nodes
        oc get pods --all-namespaces
        
        echo "OKD/OpenShift installation completed!"
        
        # Note: For production OpenShift, you would need:
        # - More resources (16GB+ RAM, 4+ CPUs)
        # - Proper DNS setup
        # - Load balancer
        # - Storage solution

  # Summary job
  summary:
    needs: [deploy-k3s, deploy-kind, deploy-k0s, deploy-microk8s, deploy-minikube, deploy-kubeadm, deploy-rke, deploy-openshift]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Generate Summary
      run: |
        echo "## Kubernetes Cluster Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Distribution | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|--------------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| k3s | ${{ needs.deploy-k3s.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| kind | ${{ needs.deploy-kind.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| k0s | ${{ needs.deploy-k0s.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| microk8s | ${{ needs.deploy-microk8s.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| minikube | ${{ needs.deploy-minikube.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| kubeadm | ${{ needs.deploy-kubeadm.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| rke | ${{ needs.deploy-rke.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| openshift | ${{ needs.deploy-openshift.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "âœ… Clusters are ready for rfruntime deployment!" >> $GITHUB_STEP_SUMMARY
